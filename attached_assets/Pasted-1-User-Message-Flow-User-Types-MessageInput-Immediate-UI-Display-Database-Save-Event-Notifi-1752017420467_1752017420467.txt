1. User Message Flow
User Types → MessageInput → Immediate UI Display → Database Save → Event Notification
2. AI Streaming Response Flow
API Request → Streaming Response → Real-time UI Updates → Complete Response → Database Save → Final UI Update
3. Key Components and Their Roles
MessageInput.tsx:
•	Handles user input and sends messages
•	Manages streaming response processing
•	Dispatches events for UI synchronization
•	Tracks accumulated content during streaming
MessageList.tsx:
•	Maintains chat history state (chatHistory)
•	Listens for custom events (userMessage, messageSaved, streamingMessage)
•	Displays messages with streaming support
•	Handles auto-scrolling and UI updates
4. Critical Event System
// User message display
window.dispatchEvent(new CustomEvent('userMessage', { detail: { message } }));
 
// Streaming content updates
window.dispatchEvent(new CustomEvent('streamingMessage', { 
  detail: { content: parsed.content, done: false } 
}));
 
// Complete response
window.dispatchEvent(new CustomEvent('streamingMessage', { 
  detail: { content: "", done: true, fullResponse: localAccumulated } 
}));
 
// Database save notifications
window.dispatchEvent(new CustomEvent('messageSaved', { 
  detail: { type: 'assistant' } 
}));
5. State Management Architecture
•	chatHistory: React state array that accumulates all messages
•	streamingMessage: Current streaming content being typed
•	isStreaming: Boolean flag for UI state
•	localAccumulated: Local tracking to avoid stale closures
6. Server-First Design
•	User messages: Show immediately → Save to database
•	AI responses: Stream to UI → Save when complete → Refresh from database
•	Database queries refresh conversation history on load
This architecture ensures:
•	✅ Immediate user feedback - messages appear instantly
•	✅ Real-time streaming - AI responses type out naturally
•	✅ Persistent storage - all messages saved to database
•	✅ Smooth conversation flow - no UI delays or glitches
•	✅ **Proper! I've thoroughly analyzed the message flow structure. Here's the current architecture that works well and must be retained:
Current Message Flow Architecture (To be Preserved)
1. User Message Flow
User Types → MessageInput → Immediate UI Display → Database Save → Event Notification
2. AI Streaming Response Flow
API Request → Streaming Response → Real-time UI Updates → Complete Response → Database Save → Final UI Update
3. Key Components and Their Roles
MessageInput.tsx:
•	Handles user input and sends messages
•	Manages streaming response processing
•	Dispatches events for UI synchronization
•	Tracks accumulated content during streaming
MessageList.tsx:
•	Maintains chat history state (chatHistory)
•	Listens for custom events (userMessage, messageSaved, streamingMessage)
•	Displays messages with streaming support
•	Handles auto-scrolling and UI updates
4. Critical Event System
// User message display
window.dispatchEvent(new CustomEvent('userMessage', { detail: { message } }));
 
// Streaming content updates
window.dispatchEvent(new CustomEvent('streamingMessage', { 
  detail: { content: parsed.content, done: false } 
}));
 
// Complete response
window.dispatchEvent(new CustomEvent('streamingMessage', { 
  detail: { content: "", done: true, fullResponse: localAccumulated } 
}));
 
// Database save notifications
window.dispatchEvent(new CustomEvent('messageSaved', { 
  detail: { type: 'assistant' } 
}));
5. State Management Architecture
•	chatHistory: React state array that accumulates all messages
•	streamingMessage: Current streaming content being typed
•	isStreaming: Boolean flag for UI state
•	localAccumulated: Local tracking to avoid stale closures
6. Server-First Design
•	User messages: Show immediately → Save to database
•	AI responses: Stream to UI → Save when complete → Refresh from database
